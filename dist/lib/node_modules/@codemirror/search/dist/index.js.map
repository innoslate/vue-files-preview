{"version":3,"file":"index.js","sources":["../../../../../../node_modules/@codemirror/search/dist/index.js"],"sourcesContent":["import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            if (norm.length)\n                for (let i = 0, pos = start;; i++) {\n                    let code = norm.charCodeAt(i);\n                    let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                    if (i == norm.length - 1) {\n                        if (match) {\n                            this.value = match;\n                            return this;\n                        }\n                        break;\n                    }\n                    if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                        pos++;\n                }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")), elt(\"button\", {\n        name: \"close\",\n        onclick: () => {\n            view.dispatch({ effects: dialogEffect.of(false) });\n            view.focus();\n        },\n        \"aria-label\": view.state.phrase(\"close\"),\n        type: \"button\"\n    }, [\"×\"]));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& label\": { fontSize: \"80%\" },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\", bottom: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: \"0\"\n        }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found)\n            found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i) => {\n            if (i == \"&\")\n                return result.match[0];\n            if (i == \"$\")\n                return \"$\";\n            for (let l = i.length; l > 0; l--) {\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length)\n                    return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match)\n        return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    let changeSet = view.state.changes(changes);\n    if (next) {\n        selection = EditorSelection.single(next.from, next.to).map(changeSet);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes: changeSet,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"×\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n"],"names":["basicNormalize","x","SearchCursor","text","query","from","to","normalize","test","codePointAt","next","str","fromCodePoint","start","codePointSize","norm","i","pos","code","match","end","index","keep","empty","baseFlags","RegExpCursor","options","MultilineRegExpCursor","startLine","toCharEnd","skip","off","flattened","FlattenedDoc","doc","cached","flat","cachedFrom","validRegExp","source","line","createLineDialog","view","input","elt","dom","event","dialogEffect","go","state","sign","ln","cl","percent","col","pc","docLine","selection","EditorSelection","EditorView","StateEffect","dialogField","StateField","value","tr","e","f","showPanel","val","gotoLine","panel","getPanel","effects","baseTheme$1","defaultHighlightOptions","highlightConfig","Facet","combineConfig","a","b","highlightSelectionMatches","defaultTheme","matchHighlighter","matchDeco","Decoration","mainMatchDeco","insideWordBoundaries","check","CharCategory","insideWord","ViewPlugin","update","conf","sel","range","word","len","deco","part","cursor","v","selectWord","dispatch","newSel","findNextOccurrence","main","ranges","fullWord","cycled","r","selectNextOccurrence","searchedText","searchConfigFacet","configs","SearchPanel","SearchQuery","config","_","ch","other","RegExpQuery","StringQuery","st","EditorState","regexpCursor","stringCursor","QueryType","spec","stringWordTest","categorizer","buf","bufPos","charBefore","charAfter","curFrom","curTo","found","_result","limit","add","regexpWordTest","findClusterBreak","_from","_to","size","result","m","l","n","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","builder","RangeSetBuilder","selected","searchCommand","openSearchPanel","findNext","announceMatch","selectSearchInput","findPrevious","prev","selectMatches","selectSelectionMatches","cur","replaceNext","changes","replacement","changeSet","replaceAll","announceText","fallback","_a","_b","_c","_d","_e","selText","getSearchInput","searchInput","searchExtensions","closeSearchPanel","searchKeymap","phrase","button","name","onclick","content","runScopeHandlers","AnnounceMargin","Break","lineEnd","baseTheme","Prec"],"mappings":"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","x_google_ignoreList":[0]}