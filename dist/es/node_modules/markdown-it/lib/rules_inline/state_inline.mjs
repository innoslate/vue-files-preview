import p from "../token.mjs";
import { isWhiteSpace as k, isMdAsciiPunct as f, isPunctChar as g } from "../common/utils.mjs";
function o(t, i, e, s) {
  this.src = t, this.env = e, this.md = i, this.tokens = s, this.tokens_meta = Array(s.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
o.prototype.pushPending = function() {
  const t = new p("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
o.prototype.push = function(t, i, e) {
  this.pending && this.pushPending();
  const s = new p(t, i, e);
  let n = null;
  return e < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), s.level = this.level, e > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], n = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(s), this.tokens_meta.push(n), s;
};
o.prototype.scanDelims = function(t, i) {
  const e = this.posMax, s = this.src.charCodeAt(t), n = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let h = t;
  for (; h < e && this.src.charCodeAt(h) === s; )
    h++;
  const v = h - t, c = h < e ? this.src.charCodeAt(h) : 32, r = f(n) || g(String.fromCharCode(n)), l = f(c) || g(String.fromCharCode(c)), a = k(n), d = k(c), m = !d && (!l || a || r), u = !a && (!r || d || l);
  return { can_open: m && (i || !u || r), can_close: u && (i || !m || l), length: v };
};
o.prototype.Token = p;
export {
  o as default
};
//# sourceMappingURL=state_inline.mjs.map
