import { getPanel as E, showPanel as $, EditorView as R, Decoration as x, hoverTooltip as z, WidgetType as H } from "../../view/dist/index.mjs";
import { StateField as _, StateEffect as S, Facet as q, combineConfig as V, RangeSetBuilder as W } from "../../state/dist/index.mjs";
import p from "../../../crelt/index.mjs";
class D {
  constructor(e, s, i) {
    this.from = e, this.to = s, this.diagnostic = i;
  }
}
class b {
  constructor(e, s, i) {
    this.diagnostics = e, this.panel = s, this.selected = i;
  }
  static init(e, s, i) {
    let o = i.facet(y).markerFilter;
    o && (e = o(e, i));
    let n = e.slice().sort((a, h) => a.from - h.from || a.to - h.to), r = new W(), l = [], d = 0;
    for (let a = 0; ; ) {
      let h = a == n.length ? null : n[a];
      if (!h && !l.length)
        break;
      let f, u;
      for (l.length ? (f = d, u = l.reduce((c, w) => Math.min(c, w.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, u = h.to, l.push(h), a++); a < n.length; ) {
        let c = n[a];
        if (c.from == f && (c.to > c.from || c.to == f))
          l.push(c), a++, u = Math.min(c.to, u);
        else {
          u = Math.min(c.from, u);
          break;
        }
      }
      let I = te(l);
      if (l.some((c) => c.from == c.to || c.from == c.to - 1 && i.doc.lineAt(c.from).to == c.from))
        r.add(f, f, x.widget({
          widget: new J(I),
          diagnostics: l.slice()
        }));
      else {
        let c = l.reduce((w, A) => A.markClass ? w + " " + A.markClass : w, "");
        r.add(f, u, x.mark({
          class: "cm-lintRange cm-lintRange-" + I + c,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((w) => w.to > u)
        }));
      }
      d = u;
      for (let c = 0; c < l.length; c++)
        l[c].to <= d && l.splice(c--, 1);
    }
    let m = r.finish();
    return new b(m, s, k(m));
  }
}
function k(t, e = null, s = 0) {
  let i = null;
  return t.between(s, 1e9, (o, n, { spec: r }) => {
    if (!(e && r.diagnostics.indexOf(e) < 0))
      if (!i)
        i = new D(o, n, e || r.diagnostics[0]);
      else {
        if (r.diagnostics.indexOf(i.diagnostic) < 0)
          return !1;
        i = new D(i.from, n, i.diagnostic);
      }
  }), i;
}
function j(t, e) {
  let s = e.pos, i = e.end || s, o = t.state.facet(y).hideOn(t, s, i);
  if (o != null)
    return o;
  let n = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((r) => r.is(T)) || t.changes.touchesRange(n.from, Math.max(n.to, i)));
}
function K(t, e) {
  return t.field(g, !1) ? e : e.concat(S.appendConfig.of(ie));
}
const T = /* @__PURE__ */ S.define(), P = /* @__PURE__ */ S.define(), B = /* @__PURE__ */ S.define(), g = /* @__PURE__ */ _.define({
  create() {
    return new b(x.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let s = t.diagnostics.map(e.changes), i = null, o = t.panel;
      if (t.selected) {
        let n = e.changes.mapPos(t.selected.from, 1);
        i = k(s, t.selected.diagnostic, n) || k(s, null, n);
      }
      !s.size && o && e.state.facet(y).autoPanel && (o = null), t = new b(s, o, i);
    }
    for (let s of e.effects)
      if (s.is(T)) {
        let i = e.state.facet(y).autoPanel ? s.value.length ? C.open : null : t.panel;
        t = b.init(s.value, i, e.state);
      } else s.is(P) ? t = new b(t.diagnostics, s.value ? C.open : null, t.selected) : s.is(B) && (t = new b(t.diagnostics, t.panel, s.value));
    return t;
  },
  provide: (t) => [
    $.from(t, (e) => e.panel),
    R.decorations.from(t, (e) => e.diagnostics)
  ]
}), N = /* @__PURE__ */ x.mark({ class: "cm-lintRange cm-lintRange-active" });
function U(t, e, s) {
  let { diagnostics: i } = t.state.field(g), o, n = -1, r = -1;
  i.between(e - (s < 0 ? 1 : 0), e + (s > 0 ? 1 : 0), (d, m, { spec: a }) => {
    if (e >= d && e <= m && (d == m || (e > d || s > 0) && (e < m || s < 0)))
      return o = a.diagnostics, n = d, r = m, !1;
  });
  let l = t.state.facet(y).tooltipFilter;
  return o && l && (o = l(o, t.state)), o ? {
    pos: n,
    end: r,
    above: t.state.doc.lineAt(n).to < r,
    create() {
      return { dom: Y(t, o) };
    }
  } : null;
}
function Y(t, e) {
  return p("ul", { class: "cm-tooltip-lint" }, e.map((s) => O(t, s, !1)));
}
const Z = (t) => {
  let e = t.state.field(g, !1);
  (!e || !e.panel) && t.dispatch({ effects: K(t.state, [P.of(!0)]) });
  let s = E(t, C.open);
  return s && s.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, L = (t) => {
  let e = t.state.field(g, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: P.of(!1) }), !0);
}, G = (t) => {
  let e = t.state.field(g, !1);
  if (!e)
    return !1;
  let s = t.state.selection.main, i = e.diagnostics.iter(s.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == s.from && i.to == s.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, le = [
  { key: "Mod-Shift-m", run: Z, preventDefault: !0 },
  { key: "F8", run: G }
], y = /* @__PURE__ */ q.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, V(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, s) => e ? s ? (i) => e(i) || s(i) : e : s
    }));
  }
});
function F(t) {
  let e = [];
  if (t)
    e: for (let { name: s } of t) {
      for (let i = 0; i < s.length; i++) {
        let o = s[i];
        if (/[a-zA-Z]/.test(o) && !e.some((n) => n.toLowerCase() == o.toLowerCase())) {
          e.push(o);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function O(t, e, s) {
  var i;
  let o = s ? F(e.actions) : [];
  return p("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, p("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((n, r) => {
    let l = !1, d = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let u = k(t.state.field(g).diagnostics, e);
      u && n.apply(t, u.from, u.to);
    }, { name: m } = n, a = o[r] ? m.indexOf(o[r]) : -1, h = a < 0 ? m : [
      m.slice(0, a),
      p("u", m.slice(a, a + 1)),
      m.slice(a + 1)
    ];
    return p("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: d,
      onmousedown: d,
      "aria-label": ` Action: ${m}${a < 0 ? "" : ` (access key "${o[r]})"`}.`
    }, h);
  }), e.source && p("div", { class: "cm-diagnosticSource" }, e.source));
}
class J extends H {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return p("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class M {
  constructor(e, s) {
    this.diagnostic = s, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = O(e, s, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class C {
  constructor(e) {
    this.view = e, this.items = [];
    let s = (o) => {
      if (o.keyCode == 27)
        L(this.view), this.view.focus();
      else if (o.keyCode == 38 || o.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (o.keyCode == 40 || o.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (o.keyCode == 36)
        this.moveSelection(0);
      else if (o.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (o.keyCode == 13)
        this.view.focus();
      else if (o.keyCode >= 65 && o.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], r = F(n.actions);
        for (let l = 0; l < r.length; l++)
          if (r[l].toUpperCase().charCodeAt(0) == o.keyCode) {
            let d = k(this.view.state.field(g).diagnostics, n);
            d && n.actions[l].apply(e, d.from, d.to);
          }
      } else
        return;
      o.preventDefault();
    }, i = (o) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(o.target) && this.moveSelection(n);
    };
    this.list = p("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: s,
      onclick: i
    }), this.dom = p("div", { class: "cm-panel-lint" }, this.list, p("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => L(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(g).selected;
    if (!e)
      return -1;
    for (let s = 0; s < this.items.length; s++)
      if (this.items[s].diagnostic == e.diagnostic)
        return s;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: s } = this.view.state.field(g), i = 0, o = !1, n = null, r = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, d, { spec: m }) => {
      for (let a of m.diagnostics) {
        if (r.has(a))
          continue;
        r.add(a);
        let h = -1, f;
        for (let u = i; u < this.items.length; u++)
          if (this.items[u].diagnostic == a) {
            h = u;
            break;
          }
        h < 0 ? (f = new M(this.view, a), this.items.splice(i, 0, f), o = !0) : (f = this.items[h], h > i && (this.items.splice(i, h - i), o = !0)), s && f.diagnostic == s.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), n = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), i++;
      }
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      o = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new M(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), o = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: d }) => {
        let m = d.height / this.list.offsetHeight;
        l.top < d.top ? this.list.scrollTop -= (d.top - l.top) / m : l.bottom > d.bottom && (this.list.scrollTop += (l.bottom - d.bottom) / m);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), o && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function s() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          s();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      s();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let s = this.view.state.field(g), i = k(s.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: B.of(i)
    });
  }
  static open(e) {
    return new C(e);
  }
}
function Q(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function v(t) {
  return Q(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const X = /* @__PURE__ */ R.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ v("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ v("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ v("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ v("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function ee(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function te(t) {
  let e = "hint", s = 1;
  for (let i of t) {
    let o = ee(i.severity);
    o > s && (s = o, e = i.severity);
  }
  return e;
}
const ie = [
  g,
  /* @__PURE__ */ R.decorations.compute([g], (t) => {
    let { selected: e, panel: s } = t.field(g);
    return !e || !s || e.from == e.to ? x.none : x.set([
      N.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ z(U, { hideOn: j }),
  X
];
export {
  L as closeLintPanel,
  le as lintKeymap,
  G as nextDiagnostic,
  Z as openLintPanel,
  T as setDiagnosticsEffect
};
//# sourceMappingURL=index.mjs.map
