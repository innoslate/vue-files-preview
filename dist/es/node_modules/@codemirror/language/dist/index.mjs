import { NodeProp as y, Tree as C, IterMode as De, TreeFragment as M, Parser as Be, NodeType as Q } from "../../../@lezer/common/dist/index.mjs";
import { Prec as Ie, Facet as w, EditorState as B, RangeSetBuilder as ae, StateField as X, StateEffect as L, combineConfig as fe, countColumn as Oe, RangeSet as Me } from "../../state/dist/index.mjs";
import { EditorView as b, ViewPlugin as Y, Decoration as p, gutter as Ne, GutterMarker as Ee, logException as Fe, WidgetType as ce, Direction as _ } from "../../view/dist/index.mjs";
import { tagHighlighter as Le, highlightTree as He, tags as u, styleTags as We } from "../../../@lezer/highlight/dist/index.mjs";
import { StyleModule as ee } from "../../../style-mod/src/style-mod.mjs";
var U;
const A = /* @__PURE__ */ new y();
function Re(n) {
  return w.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const Ue = /* @__PURE__ */ new y();
class g {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, B.prototype.hasOwnProperty("tree") || Object.defineProperty(B.prototype, "tree", { get() {
      return k(this);
    } }), this.parser = t, this.extension = [
      v.of(this),
      B.languageData.of((o, s, a) => {
        let l = te(o, s, a), f = l.type.prop(A);
        if (!f)
          return [];
        let c = o.facet(f), h = l.type.prop(Ue);
        if (h) {
          let m = l.resolve(s - l.from, a);
          for (let d of h)
            if (d.test(m, o)) {
              let S = o.facet(d.facet);
              return d.type == "replace" ? S : S.concat(c);
            }
        }
        return c;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return te(e, t, r).type.prop(A) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(v);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (o, s) => {
      if (o.prop(A) == this.data) {
        r.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(y.mounted);
      if (a) {
        if (a.tree.prop(A) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + s, to: l.to + s });
          else
            r.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + s), r.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let f = o.children[l];
        f instanceof C && i(f, o.positions[l] + s);
      }
    };
    return i(k(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
g.setState = /* @__PURE__ */ L.define();
function te(n, e, t) {
  let r = n.facet(v), i = k(n).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(e, t, De.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class G extends g {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = Re(e.languageData);
    return new G(t, e.parser.configure({
      props: [A.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new G(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function k(n) {
  let e = n.field(g.state, !1);
  return e ? e.tree : C.empty;
}
class $e {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let D = null;
class N {
  constructor(e, t, r = [], i, o, s, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new N(e, t, [], C.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new $e(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != C.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(M.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(M.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = D;
    D = this;
    try {
      return e();
    } finally {
      D = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = ne(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((f, c, h, m) => l.push({ fromA: f, toA: c, fromB: h, toB: m })), r = M.applyChanges(r, l), i = C.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let f of this.skipped) {
          let c = e.mapPos(f.from, 1), h = e.mapPos(f.to, -1);
          c < h && a.push({ from: c, to: h });
        }
      }
    }
    return new N(this.parser, t, r, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && (this.fragments = ne(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Be {
      createParse(t, r, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = D;
            if (l) {
              for (let f of i)
                l.tempSkipped.push(f);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new C(Q.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return D;
  }
}
function ne(n, e, t) {
  return M.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class P {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new P(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = N.create(e.facet(v).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new P(r);
  }
}
g.state = /* @__PURE__ */ X.define({
  create: P.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(g.setState))
        return t.value;
    return e.startState.facet(v) != e.state.facet(v) ? P.init(e.state) : n.apply(e);
  }
});
let ue = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (ue = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const $ = typeof navigator < "u" && (!((U = navigator.scheduling) === null || U === void 0) && U.isInputPending) ? () => navigator.scheduling.isInputPending() : null, qe = /* @__PURE__ */ Y.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(g.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(g.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = ue(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(g.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !$ ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => $ && $() || Date.now() > s, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: g.setState.of(new P(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Fe(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), v = /* @__PURE__ */ w.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    g.state,
    qe,
    b.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class Et {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const je = /* @__PURE__ */ w.define(), he = /* @__PURE__ */ w.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function ze(n) {
  let e = n.facet(he);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function Ge(n, e) {
  let t = "", r = n.tabSize, i = n.facet(he)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    t += i;
  return t;
}
function Je(n, e) {
  n instanceof B && (n = new de(n));
  for (let r of n.state.facet(je)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = k(n.state);
  return t.length >= e ? Ke(n, t, e) : null;
}
class de {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = ze(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to ? o && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Oe(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Ve = /* @__PURE__ */ new y();
function Ke(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let o = [];
    for (let s = i; s && !(s.from < r.node.from || s.to > r.node.to || s.from == r.node.from && s.type == r.node.type); s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      r = { node: o[s], next: r };
  }
  return pe(r, n, t);
}
function pe(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = Xe(r.node);
    if (i)
      return i(Z.create(e, t, r));
  }
  return 0;
}
function Qe(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function Xe(n) {
  let e = n.type.prop(Ve);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(y.closedBy))) {
    let i = n.lastChild, o = i && r.indexOf(i.name) > -1;
    return (s) => me(s, !0, 1, void 0, o && !Qe(s) ? i.from : void 0);
  }
  return n.parent == null ? Ye : null;
}
function Ye() {
  return 0;
}
class Z extends de {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Z(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (Ze(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return pe(this.context.next, this.base, this.pos);
  }
}
function Ze(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function _e(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, o = n.state.doc.lineAt(t.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= s)
        return null;
      let f = /^ */.exec(o.text.slice(t.to - o.from))[0].length;
      return { from: t.from, to: t.to + f };
    }
    a = l.to;
  }
}
function Ft({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => me(r, e, t, n);
}
function me(n, e, t, r, i) {
  let o = n.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == n.pos + s, l = e ? _e(n) : null;
  return l ? a ? n.column(l.from) : n.column(l.to) : n.baseIndent + (a ? 0 : n.unit * t);
}
const Lt = (n) => n.baseIndent;
function Ht({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const et = 200;
function Wt() {
  return B.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + et)
      return n;
    let o = t.sliceString(i.from, r);
    if (!e.some((f) => f.test(o)))
      return n;
    let { state: s } = n, a = -1, l = [];
    for (let { head: f } of s.selection.ranges) {
      let c = s.doc.lineAt(f);
      if (c.from == a)
        continue;
      a = c.from;
      let h = Je(s, c.from);
      if (h == null)
        continue;
      let m = /^\s*/.exec(c.text)[0], d = Ge(s, h);
      m != d && l.push({ from: c.from, to: c.from + m.length, insert: d });
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n;
  });
}
const tt = /* @__PURE__ */ w.define(), nt = /* @__PURE__ */ new y();
function Rt(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function rt(n, e, t) {
  let r = k(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), o = null;
  for (let s = i; s; s = s.next) {
    let a = s.node;
    if (a.to <= t || a.from > t)
      continue;
    if (o && a.from < e)
      break;
    let l = a.type.prop(nt);
    if (l && (a.to < r.length - 50 || r.length == n.doc.length || !it(a))) {
      let f = l(a, n);
      f && f.from <= t && f.from >= e && f.to > t && (o = f);
    }
  }
  return o;
}
function it(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function E(n, e, t) {
  for (let r of n.facet(tt)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return rt(n, e, t);
}
function ge(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const H = /* @__PURE__ */ L.define({ map: ge }), I = /* @__PURE__ */ L.define({ map: ge });
function ke(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const x = /* @__PURE__ */ X.define({
  create() {
    return p.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = re(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(H) && !ot(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(we), i = r ? p.replace({ widget: new ut(r(e.state, t.value)) }) : ie;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(I) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = re(n, e.selection.main.head)), n;
  },
  provide: (n) => b.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(ie.range(r, i));
    }
    return p.set(e, !0);
  }
});
function re(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, o) => {
    i < t && o > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, o) => i >= t || o <= e
  }) : n;
}
function F(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(x, !1)) === null || r === void 0 || r.between(e, t, (o, s) => {
    (!i || i.from > o) && (i = { from: o, to: s });
  }), i;
}
function ot(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, o) => {
    i == e && o == t && (r = !0);
  }), r;
}
function be(n, e) {
  return n.field(x, !1) ? e : e.concat(L.appendConfig.of(ve()));
}
const st = (n) => {
  for (let e of ke(n)) {
    let t = E(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: be(n.state, [H.of(t), ye(n, t)]) }), !0;
  }
  return !1;
}, lt = (n) => {
  if (!n.state.field(x, !1))
    return !1;
  let e = [];
  for (let t of ke(n)) {
    let r = F(n.state, t.from, t.to);
    r && e.push(I.of(r), ye(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function ye(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return b.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const at = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), o = E(e, i.from, i.to);
    o && t.push(H.of(o)), r = (o ? n.lineBlockAt(o.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: be(n.state, t) }), !!t.length;
}, ft = (n) => {
  let e = n.state.field(x, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(I.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, Ut = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: st },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: lt },
  { key: "Ctrl-Alt-[", run: at },
  { key: "Ctrl-Alt-]", run: ft }
], ct = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, we = /* @__PURE__ */ w.define({
  combine(n) {
    return fe(n, ct);
  }
});
function ve(n) {
  return [x, dt];
}
function xe(n, e) {
  let { state: t } = n, r = t.facet(we), i = (s) => {
    let a = n.lineBlockAt(n.posAtDOM(s.target)), l = F(n.state, a.from, a.to);
    l && n.dispatch({ effects: I.of(l) }), s.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let o = document.createElement("span");
  return o.textContent = r.placeholderText, o.setAttribute("aria-label", t.phrase("folded code")), o.title = t.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
}
const ie = /* @__PURE__ */ p.replace({ widget: /* @__PURE__ */ new class extends ce {
  toDOM(n) {
    return xe(n, null);
  }
}() });
class ut extends ce {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return xe(e, this.value);
  }
}
const ht = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class q extends Ee {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function $t(n = {}) {
  let e = { ...ht, ...n }, t = new q(e, !0), r = new q(e, !1), i = Y.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(v) != s.state.facet(v) || s.startState.field(x, !1) != s.state.field(x, !1) || k(s.startState) != k(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new ae();
      for (let l of s.viewportLineBlocks) {
        let f = F(s.state, l.from, l.to) ? r : E(s.state, l.from, l.to) ? t : null;
        f && a.add(l.from, l.from, f);
      }
      return a.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    Ne({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Me.empty;
      },
      initialSpacer() {
        return new q(e, !1);
      },
      domEventHandlers: {
        ...o,
        click: (s, a, l) => {
          if (o.click && o.click(s, a, l))
            return !0;
          let f = F(s.state, a.from, a.to);
          if (f)
            return s.dispatch({ effects: I.of(f) }), !0;
          let c = E(s.state, a.from, a.to);
          return c ? (s.dispatch({ effects: H.of(c) }), !0) : !1;
        }
      }
    }),
    ve()
  ];
}
const dt = /* @__PURE__ */ b.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class W {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(a) {
      let l = ee.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, s = t.scope;
    this.scope = s instanceof g ? (a) => a.prop(A) == s.data : s ? (a) => a == s : void 0, this.style = Le(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new ee(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new W(e, t || {});
  }
}
const J = /* @__PURE__ */ w.define(), Se = /* @__PURE__ */ w.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function j(n) {
  let e = n.facet(J);
  return e.length ? e : n.facet(Se);
}
function qt(n, e) {
  let t = [mt], r;
  return n instanceof W && (n.module && t.push(b.styleModule.of(n.module)), r = n.themeType), e != null && e.fallback ? t.push(Se.of(n)) : r ? t.push(J.computeN([b.darkTheme], (i) => i.facet(b.darkTheme) == (r == "dark") ? [n] : [])) : t.push(J.of(n)), t;
}
class pt {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = k(e.state), this.decorations = this.buildDeco(e, j(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = k(e.state), r = j(e.state), i = r != j(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    t.length < o.to && !i && t.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return p.none;
    let r = new ae();
    for (let { from: i, to: o } of e.visibleRanges)
      He(this.tree, t, (s, a, l) => {
        r.add(s, a, this.markCache[l] || (this.markCache[l] = p.mark({ class: l })));
      }, i, o);
    return r.finish();
  }
}
const mt = /* @__PURE__ */ Ie.high(/* @__PURE__ */ Y.fromClass(pt, {
  decorations: (n) => n.decorations
})), jt = /* @__PURE__ */ W.define([
  {
    tag: u.meta,
    color: "#404740"
  },
  {
    tag: u.link,
    textDecoration: "underline"
  },
  {
    tag: u.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: u.emphasis,
    fontStyle: "italic"
  },
  {
    tag: u.strong,
    fontWeight: "bold"
  },
  {
    tag: u.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: u.keyword,
    color: "#708"
  },
  {
    tag: [u.atom, u.bool, u.url, u.contentSeparator, u.labelName],
    color: "#219"
  },
  {
    tag: [u.literal, u.inserted],
    color: "#164"
  },
  {
    tag: [u.string, u.deleted],
    color: "#a11"
  },
  {
    tag: [u.regexp, u.escape, /* @__PURE__ */ u.special(u.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ u.definition(u.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ u.local(u.variableName),
    color: "#30a"
  },
  {
    tag: [u.typeName, u.namespace],
    color: "#085"
  },
  {
    tag: u.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ u.special(u.variableName), u.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ u.definition(u.propertyName),
    color: "#00c"
  },
  {
    tag: u.comment,
    color: "#940"
  },
  {
    tag: u.invalid,
    color: "#f00"
  }
]), gt = /* @__PURE__ */ b.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Te = 1e4, Ce = "()[]{}", Ae = /* @__PURE__ */ w.define({
  combine(n) {
    return fe(n, {
      afterCursor: !0,
      brackets: Ce,
      maxScanDistance: Te,
      renderMatch: yt
    });
  }
}), kt = /* @__PURE__ */ p.mark({ class: "cm-matchingBracket" }), bt = /* @__PURE__ */ p.mark({ class: "cm-nonmatchingBracket" });
function yt(n) {
  let e = [], t = n.matched ? kt : bt;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const wt = /* @__PURE__ */ X.define({
  create() {
    return p.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(Ae);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = O(e.state, i.head, -1, r) || i.head > 0 && O(e.state, i.head - 1, 1, r) || r.afterCursor && (O(e.state, i.head, 1, r) || i.head < e.state.doc.length && O(e.state, i.head + 1, -1, r));
      o && (t = t.concat(r.renderMatch(o, e.state)));
    }
    return p.set(t, !0);
  },
  provide: (n) => b.decorations.from(n)
}), vt = [
  wt,
  gt
];
function zt(n = {}) {
  return [Ae.of(n), vt];
}
const xt = /* @__PURE__ */ new y();
function V(n, e, t) {
  let r = n.prop(e < 0 ? y.openedBy : y.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function K(n) {
  let e = n.type.prop(xt);
  return e ? e(n.node) : n;
}
function O(n, e, t, r = {}) {
  let i = r.maxScanDistance || Te, o = r.brackets || Ce, s = k(n), a = s.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let f = V(l.type, t, o);
    if (f && l.from < l.to) {
      let c = K(l);
      if (c && (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return St(n, e, t, l, c, f, o);
    }
  }
  return Tt(n, e, t, s, a.type, i, o);
}
function St(n, e, t, r, i, o, s) {
  let a = r.parent, l = { from: i.from, to: i.to }, f = 0, c = a == null ? void 0 : a.cursor();
  if (c && (t < 0 ? c.childBefore(r.from) : c.childAfter(r.to)))
    do
      if (t < 0 ? c.to <= r.from : c.from >= r.to) {
        if (f == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = K(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (V(c.type, t, s))
          f++;
        else if (V(c.type, -t, s)) {
          if (f == 0) {
            let h = K(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          f--;
        }
      }
    while (t < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function Tt(n, e, t, r, i, o, s) {
  let a = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let f = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, c = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let m = 0; !c.next().done && m <= o; ) {
    let d = c.value;
    t < 0 && (m += d.length);
    let S = e + m * t;
    for (let T = t > 0 ? 0 : d.length - 1, Pe = t > 0 ? d.length : -1; T != Pe; T += t) {
      let R = s.indexOf(d[T]);
      if (!(R < 0 || r.resolveInner(S + T, 1).type != i))
        if (R % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: f, end: { from: S + T, to: S + T + 1 }, matched: R >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (m += d.length);
  }
  return c.done ? { start: f, matched: !1 } : null;
}
const Ct = /* @__PURE__ */ Object.create(null), oe = [Q.none], se = [], le = /* @__PURE__ */ Object.create(null), At = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  At[n] = /* @__PURE__ */ Pt(Ct, e);
function z(n, e) {
  se.indexOf(n) > -1 || (se.push(n), console.warn(e));
}
function Pt(n, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let f of a.split(".")) {
      let c = n[f] || u[f];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : z(f, `Modifier ${f} used at start of tag`) : l.length ? z(f, `Tag ${f} used as modifier`) : l = Array.isArray(c) ? c : [c] : z(f, `Unknown highlighting tag ${f}`);
    }
    for (let f of l)
      t.push(f);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((a) => a.id), o = le[i];
  if (o)
    return o.id;
  let s = le[i] = Q.define({
    id: oe.length,
    name: r,
    props: [We({ [r]: t })]
  });
  return oe.push(s), s.id;
}
_.RTL, _.LTR;
export {
  $e as DocInput,
  W as HighlightStyle,
  de as IndentContext,
  G as LRLanguage,
  g as Language,
  Et as LanguageSupport,
  N as ParseContext,
  Z as TreeIndentContext,
  zt as bracketMatching,
  xt as bracketMatchingHandle,
  ve as codeFolding,
  Ht as continuedIndent,
  jt as defaultHighlightStyle,
  Re as defineLanguageFacet,
  Ft as delimitedIndent,
  Lt as flatIndent,
  at as foldAll,
  st as foldCode,
  H as foldEffect,
  $t as foldGutter,
  Rt as foldInside,
  Ut as foldKeymap,
  nt as foldNodeProp,
  tt as foldService,
  x as foldState,
  E as foldable,
  ze as getIndentUnit,
  Je as getIndentation,
  Ve as indentNodeProp,
  Wt as indentOnInput,
  je as indentService,
  Ge as indentString,
  he as indentUnit,
  v as language,
  A as languageDataProp,
  O as matchBrackets,
  Ue as sublanguageProp,
  qt as syntaxHighlighting,
  k as syntaxTree,
  ft as unfoldAll,
  lt as unfoldCode,
  I as unfoldEffect
};
//# sourceMappingURL=index.mjs.map
