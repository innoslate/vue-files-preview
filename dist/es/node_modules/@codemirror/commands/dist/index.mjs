import { StateField as He, Facet as oe, EditorSelection as h, countColumn as $, Text as le, Annotation as ce, Transaction as V, combineConfig as qe, findClusterBreak as E, StateEffect as ie, ChangeSet as Ke, ChangeDesc as $e } from "../../state/dist/index.mjs";
import { EditorView as D, Direction as We } from "../../view/dist/index.mjs";
import { IndentContext as se, getIndentation as ue, indentString as R, syntaxTree as W, matchBrackets as x, getIndentUnit as G, indentUnit as Qe } from "../../language/dist/index.mjs";
import { NodeProp as F } from "../../../@lezer/common/dist/index.mjs";
const Xe = (e) => {
  let { state: t } = e, r = t.doc.lineAt(t.selection.main.from), n = X(e.state, r.from);
  return n.line ? Ye(e) : n.block ? je(e) : !1;
};
function Q(e, t) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let l = e(t, r);
    return l ? (n(r.update(l)), !0) : !1;
  };
}
const Ye = /* @__PURE__ */ Q(
  et,
  0
  /* CommentOption.Toggle */
), Ze = /* @__PURE__ */ Q(
  fe,
  0
  /* CommentOption.Toggle */
), je = /* @__PURE__ */ Q(
  (e, t) => fe(e, t, _e(t)),
  0
  /* CommentOption.Toggle */
);
function X(e, t) {
  let r = e.languageDataAt("commentTokens", t, 1);
  return r.length ? r[0] : {};
}
const M = 50;
function we(e, { open: t, close: r }, n, l) {
  let o = e.sliceDoc(n - M, n), c = e.sliceDoc(l, l + M), i = /\s*$/.exec(o)[0].length, s = /^\s*/.exec(c)[0].length, f = o.length - i;
  if (o.slice(f - t.length, f) == t && c.slice(s, s + r.length) == r)
    return {
      open: { pos: n - i, margin: i && 1 },
      close: { pos: l + s, margin: s && 1 }
    };
  let u, a;
  l - n <= 2 * M ? u = a = e.sliceDoc(n, l) : (u = e.sliceDoc(n, n + M), a = e.sliceDoc(l - M, l));
  let p = /^\s*/.exec(u)[0].length, T = /\s*$/.exec(a)[0].length, C = a.length - T - r.length;
  return u.slice(p, p + t.length) == t && a.slice(C, C + r.length) == r ? {
    open: {
      pos: n + p + t.length,
      margin: /\s/.test(u.charAt(p + t.length)) ? 1 : 0
    },
    close: {
      pos: l - T - r.length,
      margin: /\s/.test(a.charAt(C - 1)) ? 1 : 0
    }
  } : null;
}
function _e(e) {
  let t = [];
  for (let r of e.selection.ranges) {
    let n = e.doc.lineAt(r.from), l = r.to <= n.to ? n : e.doc.lineAt(r.to);
    l.from > n.from && l.from == r.to && (l = r.to == n.to + 1 ? n : e.doc.lineAt(r.to - 1));
    let o = t.length - 1;
    o >= 0 && t[o].to > n.from ? t[o].to = l.to : t.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: l.to });
  }
  return t;
}
function fe(e, t, r = t.selection.ranges) {
  let n = r.map((o) => X(t, o.from).block);
  if (!n.every((o) => o))
    return null;
  let l = r.map((o, c) => we(t, n[c], o.from, o.to));
  if (e != 2 && !l.every((o) => o))
    return { changes: t.changes(r.map((o, c) => l[c] ? [] : [{ from: o.from, insert: n[c].open + " " }, { from: o.to, insert: " " + n[c].close }])) };
  if (e != 1 && l.some((o) => o)) {
    let o = [];
    for (let c = 0, i; c < l.length; c++)
      if (i = l[c]) {
        let s = n[c], { open: f, close: u } = i;
        o.push({ from: f.pos - s.open.length, to: f.pos + f.margin }, { from: u.pos - u.margin, to: u.pos + s.close.length });
      }
    return { changes: o };
  }
  return null;
}
function et(e, t, r = t.selection.ranges) {
  let n = [], l = -1;
  for (let { from: o, to: c } of r) {
    let i = n.length, s = 1e9, f = X(t, o).line;
    if (f) {
      for (let u = o; u <= c; ) {
        let a = t.doc.lineAt(u);
        if (a.from > l && (o == c || c > a.from)) {
          l = a.from;
          let p = /^\s*/.exec(a.text)[0].length, T = p == a.length, C = a.text.slice(p, p + f.length) == f ? p : -1;
          p < a.text.length && p < s && (s = p), n.push({ line: a, comment: C, token: f, indent: p, empty: T, single: !1 });
        }
        u = a.to + 1;
      }
      if (s < 1e9)
        for (let u = i; u < n.length; u++)
          n[u].indent < n[u].line.text.length && (n[u].indent = s);
      n.length == i + 1 && (n[i].single = !0);
    }
  }
  if (e != 2 && n.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: i, token: s, indent: f, empty: u, single: a } of n)
      (a || !u) && o.push({ from: i.from + f, insert: s + " " });
    let c = t.changes(o);
    return { changes: c, selection: t.selection.map(c, 1) };
  } else if (e != 1 && n.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: c, comment: i, token: s } of n)
      if (i >= 0) {
        let f = c.from + i, u = f + s.length;
        c.text[u - c.from] == " " && u++, o.push({ from: f, to: u });
      }
    return { changes: o };
  }
  return null;
}
const z = /* @__PURE__ */ ce.define(), tt = /* @__PURE__ */ ce.define(), nt = /* @__PURE__ */ oe.define(), ae = /* @__PURE__ */ oe.define({
  combine(e) {
    return qe(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, r) => (n, l) => t(n, l) || r(n, l)
    });
  }
}), he = /* @__PURE__ */ He.define({
  create() {
    return A.empty;
  },
  update(e, t) {
    let r = t.state.facet(ae), n = t.annotation(z);
    if (n) {
      let s = m.fromTransaction(t, n.selection), f = n.side, u = f == 0 ? e.undone : e.done;
      return s ? u = I(u, u.length, r.minDepth, s) : u = pe(u, t.startState.selection), new A(f == 0 ? n.rest : u, f == 0 ? u : n.rest);
    }
    let l = t.annotation(tt);
    if ((l == "full" || l == "before") && (e = e.isolate()), t.annotation(V.addToHistory) === !1)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let o = m.fromTransaction(t), c = t.annotation(V.time), i = t.annotation(V.userEvent);
    return o ? e = e.addChanges(o, c, i, r, t) : t.selection && (e = e.addSelection(t.startState.selection, c, i, r.newGroupDelay)), (l == "full" || l == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new A(e.done.map(m.fromJSON), e.undone.map(m.fromJSON));
  }
});
function ln(e = {}) {
  return [
    he,
    ae.of(e),
    D.domEventHandlers({
      beforeinput(t, r) {
        let n = t.inputType == "historyUndo" ? de : t.inputType == "historyRedo" ? H : null;
        return n ? (t.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function v(e, t) {
  return function({ state: r, dispatch: n }) {
    if (!t && r.readOnly)
      return !1;
    let l = r.field(he, !1);
    if (!l)
      return !1;
    let o = l.pop(e, r, t);
    return o ? (n(o), !0) : !1;
  };
}
const de = /* @__PURE__ */ v(0, !1), H = /* @__PURE__ */ v(1, !1), rt = /* @__PURE__ */ v(0, !0), ot = /* @__PURE__ */ v(1, !0);
class m {
  constructor(t, r, n, l, o) {
    this.changes = t, this.effects = r, this.mapped = n, this.startSelection = l, this.selectionsAfter = o;
  }
  setSelAfter(t) {
    return new m(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, r, n;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((l) => l.toJSON())
    };
  }
  static fromJSON(t) {
    return new m(t.changes && Ke.fromJSON(t.changes), [], t.mapped && $e.fromJSON(t.mapped), t.startSelection && h.fromJSON(t.startSelection), t.selectionsAfter.map(h.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, r) {
    let n = g;
    for (let l of t.startState.facet(nt)) {
      let o = l(t);
      o.length && (n = n.concat(o));
    }
    return !n.length && t.changes.empty ? null : new m(t.changes.invert(t.startState.doc), n, void 0, r || t.startState.selection, g);
  }
  static selection(t) {
    return new m(void 0, g, void 0, void 0, t);
  }
}
function I(e, t, r, n) {
  let l = t + 1 > r + 20 ? t - r - 1 : 0, o = e.slice(l, t);
  return o.push(n), o;
}
function lt(e, t) {
  let r = [], n = !1;
  return e.iterChangedRanges((l, o) => r.push(l, o)), t.iterChangedRanges((l, o, c, i) => {
    for (let s = 0; s < r.length; ) {
      let f = r[s++], u = r[s++];
      i >= f && c <= u && (n = !0);
    }
  }), n;
}
function ct(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((r, n) => r.empty != t.ranges[n].empty).length === 0;
}
function me(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
const g = [], it = 200;
function pe(e, t) {
  if (e.length) {
    let r = e[e.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - it));
    return n.length && n[n.length - 1].eq(t) ? e : (n.push(t), I(e, e.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [m.selection([t])];
}
function st(e) {
  let t = e[e.length - 1], r = e.slice();
  return r[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), r;
}
function J(e, t) {
  if (!e.length)
    return e;
  let r = e.length, n = g;
  for (; r; ) {
    let l = ut(e[r - 1], t, n);
    if (l.changes && !l.changes.empty || l.effects.length) {
      let o = e.slice(0, r);
      return o[r - 1] = l, o;
    } else
      t = l.mapped, r--, n = l.selectionsAfter;
  }
  return n.length ? [m.selection(n)] : g;
}
function ut(e, t, r) {
  let n = me(e.selectionsAfter.length ? e.selectionsAfter.map((i) => i.map(t)) : g, r);
  if (!e.changes)
    return m.selection(n);
  let l = e.changes.map(t), o = t.mapDesc(e.changes, !0), c = e.mapped ? e.mapped.composeDesc(o) : o;
  return new m(l, ie.mapEffects(e.effects, t), c, e.startSelection.map(o), n);
}
const ft = /^(input\.type|delete)($|\.)/;
class A {
  constructor(t, r, n = 0, l = void 0) {
    this.done = t, this.undone = r, this.prevTime = n, this.prevUserEvent = l;
  }
  isolate() {
    return this.prevTime ? new A(this.done, this.undone) : this;
  }
  addChanges(t, r, n, l, o) {
    let c = this.done, i = c[c.length - 1];
    return i && i.changes && !i.changes.empty && t.changes && (!n || ft.test(n)) && (!i.selectionsAfter.length && r - this.prevTime < l.newGroupDelay && l.joinToEvent(o, lt(i.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? c = I(c, c.length - 1, l.minDepth, new m(t.changes.compose(i.changes), me(ie.mapEffects(t.effects, i.changes), i.effects), i.mapped, i.startSelection, g)) : c = I(c, c.length, l.minDepth, t), new A(c, g, r, n);
  }
  addSelection(t, r, n, l) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : g;
    return o.length > 0 && r - this.prevTime < l && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && ct(o[o.length - 1], t) ? this : new A(pe(this.done, t), this.undone, r, n);
  }
  addMapping(t) {
    return new A(J(this.done, t), J(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, r, n) {
    let l = t == 0 ? this.done : this.undone;
    if (l.length == 0)
      return null;
    let o = l[l.length - 1], c = o.selectionsAfter[0] || r.selection;
    if (n && o.selectionsAfter.length)
      return r.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: z.of({ side: t, rest: st(l), selection: c }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let i = l.length == 1 ? g : l.slice(0, l.length - 1);
      return o.mapped && (i = J(i, o.mapped)), r.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: z.of({ side: t, rest: i, selection: c }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
A.empty = /* @__PURE__ */ new A(g, g);
const cn = [
  { key: "Mod-z", run: de, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: H, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: H, preventDefault: !0 },
  { key: "Mod-u", run: rt, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ot, preventDefault: !0 }
];
function L(e, t) {
  return h.create(e.ranges.map(t), e.mainIndex);
}
function B(e, t) {
  return e.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function k({ state: e, dispatch: t }, r) {
  let n = L(e.selection, r);
  return n.eq(e.selection, !0) ? !1 : (t(B(e, n)), !0);
}
function N(e, t) {
  return h.cursor(t ? e.to : e.from);
}
function ge(e, t) {
  return k(e, (r) => r.empty ? e.moveByChar(r, t) : N(r, t));
}
function d(e) {
  return e.textDirectionAt(e.state.selection.main.head) == We.LTR;
}
const ye = (e) => ge(e, !d(e)), ke = (e) => ge(e, d(e));
function Ae(e, t) {
  return k(e, (r) => r.empty ? e.moveByGroup(r, t) : N(r, t));
}
const at = (e) => Ae(e, !d(e)), ht = (e) => Ae(e, d(e));
function dt(e, t, r) {
  if (t.type.prop(r))
    return !0;
  let n = t.to - t.from;
  return n && (n > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function P(e, t, r) {
  let n = W(e).resolveInner(t.head), l = r ? F.closedBy : F.openedBy;
  for (let s = t.head; ; ) {
    let f = r ? n.childAfter(s) : n.childBefore(s);
    if (!f)
      break;
    dt(e, f, l) ? n = f : s = r ? f.to : f.from;
  }
  let o = n.type.prop(l), c, i;
  return o && (c = r ? x(e, n.from, 1) : x(e, n.to, -1)) && c.matched ? i = r ? c.end.to : c.end.from : i = r ? n.to : n.from, h.cursor(i, r ? -1 : 1);
}
const mt = (e) => k(e, (t) => P(e.state, t, !d(e))), pt = (e) => k(e, (t) => P(e.state, t, d(e)));
function Be(e, t) {
  return k(e, (r) => {
    if (!r.empty)
      return N(r, t);
    let n = e.moveVertically(r, t);
    return n.head != r.head ? n : e.moveToLineBoundary(r, t);
  });
}
const Se = (e) => Be(e, !1), xe = (e) => Be(e, !0);
function De(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, r = 0, n = 0, l;
  if (t) {
    for (let o of e.state.facet(D.scrollMargins)) {
      let c = o(e);
      c != null && c.top && (r = Math.max(c == null ? void 0 : c.top, r)), c != null && c.bottom && (n = Math.max(c == null ? void 0 : c.bottom, n));
    }
    l = e.scrollDOM.clientHeight - r - n;
  } else
    l = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, l - 5)
  };
}
function Le(e, t) {
  let r = De(e), { state: n } = e, l = L(n.selection, (c) => c.empty ? e.moveVertically(c, t, r.height) : N(c, t));
  if (l.eq(n.selection))
    return !1;
  let o;
  if (r.selfScroll) {
    let c = e.coordsAtPos(n.selection.main.head), i = e.scrollDOM.getBoundingClientRect(), s = i.top + r.marginTop, f = i.bottom - r.marginBottom;
    c && c.top > s && c.bottom < f && (o = D.scrollIntoView(l.main.head, { y: "start", yMargin: c.top - s }));
  }
  return e.dispatch(B(n, l), { effects: o }), !0;
}
const Z = (e) => Le(e, !1), q = (e) => Le(e, !0);
function S(e, t, r) {
  let n = e.lineBlockAt(t.head), l = e.moveToLineBoundary(t, r);
  if (l.head == t.head && l.head != (r ? n.to : n.from) && (l = e.moveToLineBoundary(t, r, !1)), !r && l.head == n.from && n.length) {
    let o = /^\s*/.exec(e.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    o && t.head != n.from + o && (l = h.cursor(n.from + o));
  }
  return l;
}
const gt = (e) => k(e, (t) => S(e, t, !0)), yt = (e) => k(e, (t) => S(e, t, !1)), kt = (e) => k(e, (t) => S(e, t, !d(e))), At = (e) => k(e, (t) => S(e, t, d(e))), Bt = (e) => k(e, (t) => h.cursor(e.lineBlockAt(t.head).from, 1)), St = (e) => k(e, (t) => h.cursor(e.lineBlockAt(t.head).to, -1));
function xt(e, t, r) {
  let n = !1, l = L(e.selection, (o) => {
    let c = x(e, o.head, -1) || x(e, o.head, 1) || o.head > 0 && x(e, o.head - 1, 1) || o.head < e.doc.length && x(e, o.head + 1, -1);
    if (!c || !c.end)
      return o;
    n = !0;
    let i = c.start.from == o.head ? c.end.to : c.end.from;
    return h.cursor(i);
  });
  return n ? (t(B(e, l)), !0) : !1;
}
const Dt = ({ state: e, dispatch: t }) => xt(e, t);
function y(e, t) {
  let r = L(e.state.selection, (n) => {
    let l = t(n);
    return h.range(n.anchor, l.head, l.goalColumn, l.bidiLevel || void 0);
  });
  return r.eq(e.state.selection) ? !1 : (e.dispatch(B(e.state, r)), !0);
}
function Ce(e, t) {
  return y(e, (r) => e.moveByChar(r, t));
}
const Me = (e) => Ce(e, !d(e)), Ee = (e) => Ce(e, d(e));
function Oe(e, t) {
  return y(e, (r) => e.moveByGroup(r, t));
}
const Lt = (e) => Oe(e, !d(e)), Ct = (e) => Oe(e, d(e)), Mt = (e) => y(e, (t) => P(e.state, t, !d(e))), Et = (e) => y(e, (t) => P(e.state, t, d(e)));
function Te(e, t) {
  return y(e, (r) => e.moveVertically(r, t));
}
const be = (e) => Te(e, !1), Re = (e) => Te(e, !0);
function Ie(e, t) {
  return y(e, (r) => e.moveVertically(r, t, De(e).height));
}
const j = (e) => Ie(e, !1), w = (e) => Ie(e, !0), Ot = (e) => y(e, (t) => S(e, t, !0)), Tt = (e) => y(e, (t) => S(e, t, !1)), bt = (e) => y(e, (t) => S(e, t, !d(e))), Rt = (e) => y(e, (t) => S(e, t, d(e))), It = (e) => y(e, (t) => h.cursor(e.lineBlockAt(t.head).from)), vt = (e) => y(e, (t) => h.cursor(e.lineBlockAt(t.head).to)), _ = ({ state: e, dispatch: t }) => (t(B(e, { anchor: 0 })), !0), ee = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.doc.length })), !0), te = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.selection.main.anchor, head: 0 })), !0), ne = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.selection.main.anchor, head: e.doc.length })), !0), Nt = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), !0), Pt = ({ state: e, dispatch: t }) => {
  let r = U(e).map(({ from: n, to: l }) => h.range(n, Math.min(l + 1, e.doc.length)));
  return t(e.update({ selection: h.create(r), userEvent: "select" })), !0;
}, Ut = ({ state: e, dispatch: t }) => {
  let r = L(e.selection, (n) => {
    let l = W(e), o = l.resolveStack(n.from, 1);
    if (n.empty) {
      let c = l.resolveStack(n.from, -1);
      c.node.from >= o.node.from && c.node.to <= o.node.to && (o = c);
    }
    for (let c = o; c; c = c.next) {
      let { node: i } = c;
      if ((i.from < n.from && i.to >= n.to || i.to > n.to && i.from <= n.from) && c.next)
        return h.range(i.to, i.from);
    }
    return n;
  });
  return r.eq(e.selection) ? !1 : (t(B(e, r)), !0);
}, Vt = ({ state: e, dispatch: t }) => {
  let r = e.selection, n = null;
  return r.ranges.length > 1 ? n = h.create([r.main]) : r.main.empty || (n = h.create([h.cursor(r.main.head)])), n ? (t(B(e, n)), !0) : !1;
};
function O(e, t) {
  if (e.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = e, l = n.changeByRange((o) => {
    let { from: c, to: i } = o;
    if (c == i) {
      let s = t(o);
      s < c ? (r = "delete.backward", s = b(e, s, !1)) : s > c && (r = "delete.forward", s = b(e, s, !0)), c = Math.min(c, s), i = Math.max(i, s);
    } else
      c = b(e, c, !1), i = b(e, i, !0);
    return c == i ? { range: o } : { changes: { from: c, to: i }, range: h.cursor(c, c < o.head ? -1 : 1) };
  });
  return l.changes.empty ? !1 : (e.dispatch(n.update(l, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? D.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function b(e, t, r) {
  if (e instanceof D)
    for (let n of e.state.facet(D.atomicRanges).map((l) => l(e)))
      n.between(t, t, (l, o) => {
        l < t && o > t && (t = r ? o : l);
      });
  return t;
}
const ve = (e, t, r) => O(e, (n) => {
  let l = n.from, { state: o } = e, c = o.doc.lineAt(l), i, s;
  if (r && !t && l > c.from && l < c.from + 200 && !/[^ \t]/.test(i = c.text.slice(0, l - c.from))) {
    if (i[i.length - 1] == "	")
      return l - 1;
    let f = $(i, o.tabSize), u = f % G(o) || G(o);
    for (let a = 0; a < u && i[i.length - 1 - a] == " "; a++)
      l--;
    s = l;
  } else
    s = E(c.text, l - c.from, t, t) + c.from, s == l && c.number != (t ? o.doc.lines : 1) ? s += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(c.text.slice(s - c.from, l - c.from)) && (s = E(c.text, s - c.from, !1, !1) + c.from);
  return s;
}), K = (e) => ve(e, !1, !0), Ne = (e) => ve(e, !0, !1), Pe = (e, t) => O(e, (r) => {
  let n = r.head, { state: l } = e, o = l.doc.lineAt(n), c = l.charCategorizer(n);
  for (let i = null; ; ) {
    if (n == (t ? o.to : o.from)) {
      n == r.head && o.number != (t ? l.doc.lines : 1) && (n += t ? 1 : -1);
      break;
    }
    let s = E(o.text, n - o.from, t) + o.from, f = o.text.slice(Math.min(n, s) - o.from, Math.max(n, s) - o.from), u = c(f);
    if (i != null && u != i)
      break;
    (f != " " || n != r.head) && (i = u), n = s;
  }
  return n;
}), Ue = (e) => Pe(e, !1), Jt = (e) => Pe(e, !0), Gt = (e) => O(e, (t) => {
  let r = e.lineBlockAt(t.head).to;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
}), Ft = (e) => O(e, (t) => {
  let r = e.moveToLineBoundary(t, !1).head;
  return t.head > r ? r : Math.max(0, t.head - 1);
}), zt = (e) => O(e, (t) => {
  let r = e.moveToLineBoundary(t, !0).head;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
}), Ht = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = e.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: le.of(["", ""]) },
    range: h.cursor(n.from)
  }));
  return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, qt = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = e.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == e.doc.length)
      return { range: n };
    let l = n.from, o = e.doc.lineAt(l), c = l == o.from ? l - 1 : E(o.text, l - o.from, !1) + o.from, i = l == o.to ? l + 1 : E(o.text, l - o.from, !0) + o.from;
    return {
      changes: { from: c, to: i, insert: e.doc.slice(l, i).append(e.doc.slice(c, l)) },
      range: h.cursor(i)
    };
  });
  return r.changes.empty ? !1 : (t(e.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function U(e) {
  let t = [], r = -1;
  for (let n of e.selection.ranges) {
    let l = e.doc.lineAt(n.from), o = e.doc.lineAt(n.to);
    if (!n.empty && n.to == o.from && (o = e.doc.lineAt(n.to - 1)), r >= l.number) {
      let c = t[t.length - 1];
      c.to = o.to, c.ranges.push(n);
    } else
      t.push({ from: l.from, to: o.to, ranges: [n] });
    r = o.number + 1;
  }
  return t;
}
function Ve(e, t, r) {
  if (e.readOnly)
    return !1;
  let n = [], l = [];
  for (let o of U(e)) {
    if (r ? o.to == e.doc.length : o.from == 0)
      continue;
    let c = e.doc.lineAt(r ? o.to + 1 : o.from - 1), i = c.length + 1;
    if (r) {
      n.push({ from: o.to, to: c.to }, { from: o.from, insert: c.text + e.lineBreak });
      for (let s of o.ranges)
        l.push(h.range(Math.min(e.doc.length, s.anchor + i), Math.min(e.doc.length, s.head + i)));
    } else {
      n.push({ from: c.from, to: o.from }, { from: o.to, insert: e.lineBreak + c.text });
      for (let s of o.ranges)
        l.push(h.range(s.anchor - i, s.head - i));
    }
  }
  return n.length ? (t(e.update({
    changes: n,
    scrollIntoView: !0,
    selection: h.create(l, e.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Kt = ({ state: e, dispatch: t }) => Ve(e, t, !1), $t = ({ state: e, dispatch: t }) => Ve(e, t, !0);
function Je(e, t, r) {
  if (e.readOnly)
    return !1;
  let n = [];
  for (let l of U(e))
    r ? n.push({ from: l.from, insert: e.doc.slice(l.from, l.to) + e.lineBreak }) : n.push({ from: l.to, insert: e.lineBreak + e.doc.slice(l.from, l.to) });
  return t(e.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Wt = ({ state: e, dispatch: t }) => Je(e, t, !1), Qt = ({ state: e, dispatch: t }) => Je(e, t, !0), Xt = (e) => {
  if (e.state.readOnly)
    return !1;
  let { state: t } = e, r = t.changes(U(t).map(({ from: l, to: o }) => (l > 0 ? l-- : o < t.doc.length && o++, { from: l, to: o }))), n = L(t.selection, (l) => {
    let o;
    if (e.lineWrapping) {
      let c = e.lineBlockAt(l.head), i = e.coordsAtPos(l.head, l.assoc || 1);
      i && (o = c.bottom + e.documentTop - i.bottom + e.defaultLineHeight / 2);
    }
    return e.moveVertically(l, !0, o);
  }).map(r);
  return e.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Yt(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let r = W(e).resolveInner(t), n = r.childBefore(t), l = r.childAfter(t), o;
  return n && l && n.to <= t && l.from >= t && (o = n.type.prop(F.closedBy)) && o.indexOf(l.name) > -1 && e.doc.lineAt(n.to).from == e.doc.lineAt(l.from).from && !/\S/.test(e.sliceDoc(n.to, l.from)) ? { from: n.to, to: l.from } : null;
}
const re = /* @__PURE__ */ Ge(!1), Zt = /* @__PURE__ */ Ge(!0);
function Ge(e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let n = t.changeByRange((l) => {
      let { from: o, to: c } = l, i = t.doc.lineAt(o), s = !e && o == c && Yt(t, o);
      e && (o = c = (c <= i.to ? i : t.doc.lineAt(c)).to);
      let f = new se(t, { simulateBreak: o, simulateDoubleBreak: !!s }), u = ue(f, o);
      for (u == null && (u = $(/^\s*/.exec(t.doc.lineAt(o).text)[0], t.tabSize)); c < i.to && /\s/.test(i.text[c - i.from]); )
        c++;
      s ? { from: o, to: c } = s : o > i.from && o < i.from + 100 && !/\S/.test(i.text.slice(0, o)) && (o = i.from);
      let a = ["", R(t, u)];
      return s && a.push(R(t, f.lineIndent(i.from, -1))), {
        changes: { from: o, to: c, insert: le.of(a) },
        range: h.cursor(o + 1 + a[1].length)
      };
    });
    return r(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Y(e, t) {
  let r = -1;
  return e.changeByRange((n) => {
    let l = [];
    for (let c = n.from; c <= n.to; ) {
      let i = e.doc.lineAt(c);
      i.number > r && (n.empty || n.to > i.from) && (t(i, l, n), r = i.number), c = i.to + 1;
    }
    let o = e.changes(l);
    return {
      changes: l,
      range: h.range(o.mapPos(n.anchor, 1), o.mapPos(n.head, 1))
    };
  });
}
const jt = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new se(e, { overrideIndentation: (o) => {
    let c = r[o];
    return c ?? -1;
  } }), l = Y(e, (o, c, i) => {
    let s = ue(n, o.from);
    if (s == null)
      return;
    /\S/.test(o.text) || (s = 0);
    let f = /^\s*/.exec(o.text)[0], u = R(e, s);
    (f != u || i.from < o.from + f.length) && (r[o.from] = s, c.push({ from: o.from, to: o.from + f.length, insert: u }));
  });
  return l.changes.empty || t(e.update(l, { userEvent: "indent" })), !0;
}, Fe = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Y(e, (r, n) => {
  n.push({ from: r.from, insert: e.facet(Qe) });
}), { userEvent: "input.indent" })), !0), ze = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Y(e, (r, n) => {
  let l = /^\s*/.exec(r.text)[0];
  if (!l)
    return;
  let o = $(l, e.tabSize), c = 0, i = R(e, Math.max(0, o - G(e)));
  for (; c < l.length && c < i.length && l.charCodeAt(c) == i.charCodeAt(c); )
    c++;
  n.push({ from: r.from + c, to: r.from + l.length, insert: i.slice(c) });
}), { userEvent: "delete.dedent" })), !0), wt = (e) => (e.setTabFocusMode(), !0), _t = [
  { key: "Ctrl-b", run: ye, shift: Me, preventDefault: !0 },
  { key: "Ctrl-f", run: ke, shift: Ee },
  { key: "Ctrl-p", run: Se, shift: be },
  { key: "Ctrl-n", run: xe, shift: Re },
  { key: "Ctrl-a", run: Bt, shift: It },
  { key: "Ctrl-e", run: St, shift: vt },
  { key: "Ctrl-d", run: Ne },
  { key: "Ctrl-h", run: K },
  { key: "Ctrl-k", run: Gt },
  { key: "Ctrl-Alt-h", run: Ue },
  { key: "Ctrl-o", run: Ht },
  { key: "Ctrl-t", run: qt },
  { key: "Ctrl-v", run: q }
], en = /* @__PURE__ */ [
  { key: "ArrowLeft", run: ye, shift: Me, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: at, shift: Lt, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: kt, shift: bt, preventDefault: !0 },
  { key: "ArrowRight", run: ke, shift: Ee, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: ht, shift: Ct, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: At, shift: Rt, preventDefault: !0 },
  { key: "ArrowUp", run: Se, shift: be, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: _, shift: te },
  { mac: "Ctrl-ArrowUp", run: Z, shift: j },
  { key: "ArrowDown", run: xe, shift: Re, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: ee, shift: ne },
  { mac: "Ctrl-ArrowDown", run: q, shift: w },
  { key: "PageUp", run: Z, shift: j },
  { key: "PageDown", run: q, shift: w },
  { key: "Home", run: yt, shift: Tt, preventDefault: !0 },
  { key: "Mod-Home", run: _, shift: te },
  { key: "End", run: gt, shift: Ot, preventDefault: !0 },
  { key: "Mod-End", run: ee, shift: ne },
  { key: "Enter", run: re, shift: re },
  { key: "Mod-a", run: Nt },
  { key: "Backspace", run: K, shift: K },
  { key: "Delete", run: Ne },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Ue },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Jt },
  { mac: "Mod-Backspace", run: Ft },
  { mac: "Mod-Delete", run: zt }
].concat(/* @__PURE__ */ _t.map((e) => ({ mac: e.key, run: e.run, shift: e.shift }))), sn = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: mt, shift: Mt },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: pt, shift: Et },
  { key: "Alt-ArrowUp", run: Kt },
  { key: "Shift-Alt-ArrowUp", run: Wt },
  { key: "Alt-ArrowDown", run: $t },
  { key: "Shift-Alt-ArrowDown", run: Qt },
  { key: "Escape", run: Vt },
  { key: "Mod-Enter", run: Zt },
  { key: "Alt-l", mac: "Ctrl-l", run: Pt },
  { key: "Mod-i", run: Ut, preventDefault: !0 },
  { key: "Mod-[", run: ze },
  { key: "Mod-]", run: Fe },
  { key: "Mod-Alt-\\", run: jt },
  { key: "Shift-Mod-k", run: Xt },
  { key: "Shift-Mod-\\", run: Dt },
  { key: "Mod-/", run: Xe },
  { key: "Alt-A", run: Ze },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: wt }
].concat(en), un = { key: "Tab", run: Fe, shift: ze };
export {
  Qt as copyLineDown,
  Wt as copyLineUp,
  ye as cursorCharLeft,
  ke as cursorCharRight,
  ee as cursorDocEnd,
  _ as cursorDocStart,
  at as cursorGroupLeft,
  ht as cursorGroupRight,
  yt as cursorLineBoundaryBackward,
  gt as cursorLineBoundaryForward,
  kt as cursorLineBoundaryLeft,
  At as cursorLineBoundaryRight,
  xe as cursorLineDown,
  St as cursorLineEnd,
  Bt as cursorLineStart,
  Se as cursorLineUp,
  Dt as cursorMatchingBracket,
  q as cursorPageDown,
  Z as cursorPageUp,
  mt as cursorSyntaxLeft,
  pt as cursorSyntaxRight,
  sn as defaultKeymap,
  K as deleteCharBackward,
  Ne as deleteCharForward,
  Ue as deleteGroupBackward,
  Jt as deleteGroupForward,
  Xt as deleteLine,
  Ft as deleteLineBoundaryBackward,
  zt as deleteLineBoundaryForward,
  Gt as deleteToLineEnd,
  _t as emacsStyleKeymap,
  ln as history,
  cn as historyKeymap,
  ze as indentLess,
  Fe as indentMore,
  jt as indentSelection,
  un as indentWithTab,
  Zt as insertBlankLine,
  re as insertNewlineAndIndent,
  nt as invertedEffects,
  tt as isolateHistory,
  $t as moveLineDown,
  Kt as moveLineUp,
  H as redo,
  ot as redoSelection,
  Nt as selectAll,
  Me as selectCharLeft,
  Ee as selectCharRight,
  ne as selectDocEnd,
  te as selectDocStart,
  Lt as selectGroupLeft,
  Ct as selectGroupRight,
  Pt as selectLine,
  Tt as selectLineBoundaryBackward,
  Ot as selectLineBoundaryForward,
  bt as selectLineBoundaryLeft,
  Rt as selectLineBoundaryRight,
  Re as selectLineDown,
  vt as selectLineEnd,
  It as selectLineStart,
  be as selectLineUp,
  w as selectPageDown,
  j as selectPageUp,
  Ut as selectParentSyntax,
  Mt as selectSyntaxLeft,
  Et as selectSyntaxRight,
  Vt as simplifySelection,
  Ht as splitLine,
  en as standardKeymap,
  Ze as toggleBlockComment,
  je as toggleBlockCommentByLine,
  Xe as toggleComment,
  Ye as toggleLineComment,
  wt as toggleTabFocusMode,
  qt as transposeChars,
  de as undo,
  rt as undoSelection
};
//# sourceMappingURL=index.mjs.map
